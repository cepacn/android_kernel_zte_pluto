/*
 * ov9740.c - ov9740 sensor driver
 *
 * Copyright (c) 2012, NVIDIA, All Rights Reserved.
 *
 * Contributors:
 *      Krupal Divvela <kdivvela@nvidia.com>
 *
 *
 * This file is licensed under the terms of the GNU General Public License
 * version 2. This program is licensed "as is" without any warranty of any
 * kind, whether express or implied.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/regulator/consumer.h>
#include <media/ov9740.h>
#include <linux/gpio.h>
#include <linux/module.h>
#include <linux/moduleparam.h>

enum ov9740_width {
	WORD_LEN,
	BYTE_LEN
};

struct ov9740_reg {
	u16 addr;
	u16 val;
};

struct ov9740_info {
	struct miscdevice		miscdev_info;
	int				mode;
	struct i2c_client		*i2c_client;
	struct ov9740_platform_data	*pdata;
	atomic_t			in_use;
};

#define OV9740_TABLE_WAIT_MS 0
#define OV9740_TABLE_END 1

#define OV9740_WAIT_MS 5
#define OV9740_MAX_RETRIES 3
//#define SENSOR_WIDTH_REG      0x2703
//#define SENSOR_640_WIDTH_VAL  0x280
//#define SENSOR_720_WIDTH_VAL  0x500
//#define SENSOR_1600_WIDTH_VAL 0x640

static struct ov9740_reg  ov9740_brightness_level1[] = {
	
	{0x5587, 0x40 },
	{0x5588, 0x09,	},
	{OV9740_TABLE_END, 0x0000}
	
};
static  struct ov9740_reg  ov9740_brightness_level2[] = {
	
	{0x5587, 0x20 },
	{0x5588, 0x09 },
	{OV9740_TABLE_END, 0x0000}
	
};
static  struct ov9740_reg  ov9740_brightness_level3[] = {
	{0x5587, 0x00 },
	{0x5588, 0x01 },
	{OV9740_TABLE_END, 0x0000}
};
static  struct ov9740_reg  ov9740_brightness_level4[] = {
	{0x5587, 0x20 },
	{0x5588, 0x01 },
	{OV9740_TABLE_END, 0x0000}
	
};
static  struct ov9740_reg   ov9740_brightness_level5[] = {
	
	{0x5587, 0x30},
	{0x5588, 0x01},
	{OV9740_TABLE_END, 0x0000}
};
static  struct ov9740_reg   ov9740_brightness_level6[] = {
	{0x5587,0x40 },
	{0x5588, 0x01 },
	
	{OV9740_TABLE_END, 0x0000}
};
static struct ov9740_reg Whitebalance_Auto[] = {
	
	{0x3406, 0x00},		// LOGICAL_ADDRESS_ACCESS  
		// CAM_AWB_AWBMODE           
		
	{OV9740_TABLE_END, 0x00}
};
//白炽
static struct ov9740_reg Whitebalance_Incandescent[] = {
	{0x3406, 0x01 },	// LOGICAL_ADDRESS_ACCESS       
	{0x3400, 0x04 }	,// CAM_AWB_AWBMODE               
	{0x3401, 0xa9},// CAM_AWB_COLOR_TEMPERATURE    
	{0x3402, 0x04},
	{0x3403, 0x00},
	{0x3404, 0x09},
	{0x3405, 0x0e},
	{OV9740_TABLE_END, 0x00}
};
// 日光 
static struct ov9740_reg Whitebalance_Daylight[] = {
	{0x3406, 0x01 },	       
	{0x3400, 0x07 },              
	{0x3401, 0x5c},    
	{0x3402, 0x04},
	{0x3403, 0x00},
	{0x3404, 0x04},
	{0x3405, 0x74},
	{OV9740_TABLE_END, 0x00}
};
// 荧光
static struct ov9740_reg Whitebalance_Fluorescent[] = {
	
	{0x3406, 0x01 },	       
	{0x3400, 0x06 },              
	{0x3401, 0xcf},    
	{0x3402, 0x04},
	{0x3403, 0x00},
	{0x3404, 0x08},
	{0x3405, 0x0b},
	{OV9740_TABLE_END, 0x00}
};

//阴天
static struct ov9740_reg Whitebalance_Cloudy[]={
	
	{0x3406, 0x01 },	       
	{0x3400, 0x08 },              
	{0x3401, 0x26},    
	{0x3402, 0x04},
	{0x3403, 0x00},
	{0x3404, 0x04},
	{0x3405, 0x4d},
	{OV9740_TABLE_END, 0x00} 
};
/* contrast level register setting*/
static struct ov9740_reg ov9740_contrast_level1[] = {
	
	{0x5586, 0x0d },	// LOGICAL_ADDRESS_ACCESS [CAM_LL_GAMMA] 
		
		
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ov9740_contrast_level2[] = {
	{0x5586, 0x14 },
		
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ov9740_contrast_level3[] = {
	{0x5586, 0x20 },                      
		
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ov9740_contrast_level4[] = {
	
	{0x5586, 0x30 },                         
		
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg  ov9740_contrast_level5[] = {
	{0x5586, 0x40 },                      
		
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ColorEffect_None[] = { 
	
	{0x5580, 0x06}, 	
	{0x5583, 0x40}, 	                      
	{0x5584, 0x40},	                     
	
	
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ColorEffect_Mono[] = {
	{0x5580, 0x26},                         
		
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ColorEffect_Sepia[] = {
	
	{0x5580, 0x1e}, 	
	{0x5583, 0x40}, 	                      
	{0x5584, 0xa0},	                      
	
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ColorEffect_Negative[] = {
	
	{0x5580, 0x46}, 	
	{0x5583, 0x40}, 	                      
	{0x5584, 0x40},	
	{OV9740_TABLE_END, 0x00} 
};

static struct ov9740_reg ColorEffect_Bluish[] = {
	
	
	{0x5580, 0x1e}, 	
	{0x5583, 0xa0}, 	                      
	{0x5584, 0x40},	                          
	
	{OV9740_TABLE_END, 0x00} 
};
static struct ov9740_reg mode_640x480[] = { 
	{OV9740_TABLE_WAIT_MS, 100}, 

//, 0xSoftware, 0xRESET
{0x0103, 0x01}, //Software, 0xRESET

//, 0xOrientation
{0x0101, 0x01}, //Orientation

//, 0xPLL, 0xsetting
{0x3104, 0x20}, //PLL, 0xmode, 0xcontrol
{0x0305, 0x03}, //PLL, 0xcontrol
{0x0307, 0x4c}, //PLL, 0xcontrol
{0x0303, 0x01}, //PLL, 0xcontrol
{0x0301, 0x08}, //PLL, 0xcontrol
{0x3010, 0x01}, //PLL, 0xcontrol
{0x300e, 0x12}, //

//, 0xTiming, 0xsetting
{0x0340, 0x03}, //VTS
{0x0341, 0x07}, //VTS
{0x0342, 0x06}, //HTS
{0x0343, 0x62}, //HTS
{0x0344, 0x00}, //Xstart
{0x0345, 0xa8}, //Xstart
{0x0346, 0x00}, //Ystart
{0x0347, 0x04}, //Ystart
{0x0348, 0x04}, //Xend
{0x0349, 0x67}, //Xend
{0x034a, 0x02}, //Yend
{0x034b, 0xd8}, //Yend
{0x034c, 0x02}, //Houtputsize
{0x034d, 0x80}, //Houtputsize
{0x034e, 0x01}, //Voutputsize
{0x034f, 0xe0}, //Voutputsize

// Output select
{0x3002, 0x00}, //IOcontrol
{0x3004, 0x00}, //IOcontrol
{0x3005, 0x00}, //IOcontrol
{0x3012, 0x70}, //MIPI control
{0x3013, 0x60}, //MIPI control
{0x3014, 0x01}, //MIPI control
{0x3026, 0x00}, //Output select
{0x3027, 0x00}, //Output select


//, 0xAnalog, 0xcontrol
{0x3601, 0x40}, //Analog control
{0x3602, 0x16}, //Analog control
{0x3603, 0xaa}, //Analog control
{0x3604, 0x0c}, //Analog control
{0x3610, 0xa1}, //Analog control
{0x3612, 0x24}, //Analog control
{0x3620, 0x66}, //Analog control
{0x3621, 0xc0}, //Analog control
{0x3622, 0x9f}, //Analog control
{0x3630, 0xca}, //Analog control
{0x3631, 0x52}, //Analog control
{0x3632, 0x2f}, //Analog control
{0x3633, 0x50}, //Analog control

// Sensor control
{0x3703, 0x42}, //Sensor control 
{0x3704, 0x10}, //Sensor control
{0x3705, 0x45}, //Sensor control
{0x3707, 0x11}, //Sensor control

//, 0xTiming, 0xcontrol
{0x3833, 0x04}, //Internal timing control
{0x3835, 0x04}, //Internal timing control
{0x3819, 0x6e}, //Internal timing control
{0x3817, 0x94}, //Internal timing control
{0x3831, 0x40}, //Digital gain enable
{0x3837, 0x01}, //Internal timing control

//, 0xAEC/AGC, 0xcontrol
{0x3503, 0x10}, //AEC/AGC control
{0x3a18, 0x01}, //Gain ceiling
{0x3a19, 0xB5}, //Gain ceiling
{0x3a1a, 0x05}, //Max diff
{0x3a11, 0x90}, //High threshold
{0x3a1b, 0x4a}, //WPT 2 
{0x3a0f, 0x48}, //WPT  
{0x3a10, 0x44}, //BPT 
{0x3a1e, 0x42}, //BPT 2
{0x3a1f, 0x22}, //Low threshold 

//, 0xBanding, 0xfilter
{0x3a08, 0x00}, //50Hz banding step
{0x3a09, 0xe8}, //50Hz banding step	
{0x3a0e, 0x03}, //50Hz banding Max
{0x3a14, 0x15}, //50Hz Max exposure
{0x3a15, 0xc6}, //50Hz Max exposure
{0x3a0a, 0x00}, //60Hz banding step
{0x3a0b, 0xc0}, //60Hz banding step
{0x3a0d, 0x04}, //60Hz banding Max
{0x3a02, 0x18}, //60Hz Max exposure
{0x3a03, 0x20}, //60Hz Max exposure

//50/60, 0xdetection
{0x3c0a, 0x9c}, //Number of samples
{0x3c0b, 0x3f}, //Number of samples

//, 0xBLC, 0xcontrol
{0x4002, 0x45}, //BLC auto enable
{0x4005, 0x18}, //BLC mode
//YVYU
{0x4300,0x32},
//, 0xVFIFO
{0x4601, 0x16}, //VFIFO control
{0x4608, 0x02}, //VFIFO control
{0x4609, 0x70}, //VFIFO control
{0x460e, 0x82}, //VFIFO control

//, 0xDVP, 0xcontrol
{0x4702, 0x04}, //Vsync control
{0x4704, 0x00}, //Vsync mode 
{0x4706, 0x08}, //Vsync control

//, 0xMIPI, 0xcontrol
{0x4800, 0x44}, //MIPI control
{0x4801, 0x0f}, //MIPI control
{0x4803, 0x05}, //MIPI control
{0x4805, 0x10}, //MIPI control
{0x4837, 0x20}, //MIPI control

//, 0xISP, 0xcontrol
{0x5000, 0xff}, //[7]LC [6]Gamma [3]DNS [2]BPC [1]WPC [0]CIP
{0x5001, 0xff}, //[7]SDE [6]UV adjust [4]scale [3]contrast [2]UV average [1]CMX [0]AWB
{0x5003, 0xff}, //[7]PAD [5]Buffer [3]Vario [1]BLC [0]AWB gain

//, 0xScaling
{0x501e, 0x03}, //Scale, 0xX input
{0x501f, 0xc0}, //Scale, 0xX input
{0x5020, 0x02}, //Scale, 0xY input
{0x5021, 0xd0}, //Scale, 0xY, 0xinput

//AWB
{0x5180, 0xf0}, //AWB, 0xsetting
{0x5181, 0x00}, //AWB, 0xsetting
{0x5182, 0x41}, //AWB, 0xsetting, 0x
{0x5183, 0x42}, //AWB, 0xsetting
{0x5184, 0x80}, //AWB, 0xsetting
{0x5185, 0x68}, //AWB, 0xsetting
{0x5186, 0x93}, //AWB, 0xsetting, 0x
{0x5187, 0xa8}, //AWB, 0xsetting
{0x5188, 0x17}, //AWB, 0xsetting
{0x5189, 0x45}, //AWB, 0xsetting
{0x518a, 0x27}, //AWB, 0xsetting
{0x518b, 0x41}, //AWB, 0xsetting
{0x518c, 0x2d}, //AWB, 0xsetting
{0x518d, 0xf0}, //AWB, 0xsetting
{0x518e, 0x10}, //AWB, 0xsetting
{0x518f, 0xff}, //AWB, 0xsetting
{0x5190, 0x0}, //AWB, 0xsetting
{0x5191, 0xff}, //AWB, 0xsetting, 0x
{0x5192, 0x00}, //AWB, 0xsetting
{0x5193, 0xff}, //AWB, 0xsetting, 0x
{0x5194, 0x00}, //AWB, 0xsetting, 0x

//, 0xDNS
{0x529a, 0x02}, //DNS, 0xsetting
{0x529b, 0x08}, //DNS, 0xsetting
{0x529c, 0x0a}, //DNS, 0xsetting
{0x529d, 0x10}, //DNS, 0xsetting
{0x529e, 0x10}, //DNS, 0xsetting
{0x529f, 0x28}, //DNS, 0xsetting
{0x52a0, 0x32}, //DNS, 0xsetting
{0x52a2, 0x00}, //DNS, 0xsetting, 0x
{0x52a3, 0x02}, //DNS, 0xsetting, 0x
{0x52a4, 0x00}, //DNS, 0xsetting, 0x
{0x52a5, 0x04}, //DNS, 0xsetting, 0x, 0x
{0x52a6, 0x00}, //DNS, 0xsetting, 0x, 0x
{0x52a7, 0x08}, //DNS, 0xsetting, 0x, 0x
{0x52a8, 0x00}, //DNS, 0xsetting, 0x, 0x
{0x52a9, 0x10}, //DNS, 0xsetting
{0x52aa, 0x00}, //DNS, 0xsetting, 0x, 0x
{0x52ab, 0x38}, //DNS, 0xsetting
{0x52ac, 0x00}, //DNS, 0xsetting, 0x, 0x
{0x52ad, 0x3c}, //DNS, 0xsetting, 0x
{0x52ae, 0x00}, //DNS, 0xsetting, 0x, 0x, 0x
{0x52af, 0x4c}, //DNS, 0xsetting

//CIP
{0x530d, 0x06}, //CIP, 0xsetting

//CMX
{0x5380, 0x01}, //CMX, 0xsetting, 0x, 0x
{0x5381, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x5382, 0x00}, //CMX, 0xsetting, 0x, 0x, 0x
{0x5383, 0x0d}, //CMX, 0xsetting, 0x, 0x
{0x5384, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x5385, 0x2f}, //CMX, 0xsetting, 0x, 0x, 0x
{0x5386, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x5387, 0x00}, //CMX, 0xsetting, 0x, 0x, 0x
{0x5388, 0x00}, //CMX, 0xsetting, 0x, 0x, 0x
{0x5389, 0xd3}, //CMX, 0xsetting, 0x, 0x
{0x538a, 0x00}, //CMX, 0xsetting, 0x, 0x, 0x
{0x538b, 0x0f}, //CMX, 0xsetting, 0x, 0x, 0x
{0x538c, 0x00}, //CMX, 0xsetting, 0x, 0x, 0x
{0x538d, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x538e, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x538f, 0x32}, //CMX, 0xsetting, 0x, 0x, 0x
{0x5390, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x5391, 0x94}, //CMX, 0xsetting, 0x, 0x, 0x, 0x
{0x5392, 0x00}, //CMX, 0xsetting, 0x, 0x
{0x5393, 0xa4}, //CMX, 0xsetting, 0x, 0x
{0x5394, 0x18}, //CMX, 0xsetting, 0x, 0x

//, 0xContrast
{0x5401, 0x2c}, //Contrast, 0xsetting
{0x5403, 0x28}, //Contrast, 0xsetting
{0x5404, 0x06}, //Contrast, 0xsetting	
{0x5405, 0xe0}, //Contrast, 0xsetting

//Y, 0xGamma
{0x5480, 0x04}, //Y, 0xGamma, 0xsetting, 0x, 0x
{0x5481, 0x12}, //Y, 0xGamma, 0xsetting, 0x
{0x5482, 0x27}, //Y, 0xGamma, 0xsetting, 0x, 0x
{0x5483, 0x49}, //Y, 0xGamma, 0xsetting, 0x, 0x
{0x5484, 0x57}, //Y, 0xGamma, 0xsetting, 0x, 0x
{0x5485, 0x66}, //Y, 0xGamma, 0xsetting, 0x, 0x
{0x5486, 0x75}, //Y, 0xGamma, 0xsetting, 0x, 0x
{0x5487, 0x81}, //Y, 0xGamma, 0xsetting, 0x
{0x5488, 0x8c}, //Y, 0xGamma, 0xsetting, 0x
{0x5489, 0x95}, //Y, 0xGamma, 0xsetting, 0x
{0x548a, 0xa5}, //Y, 0xGamma, 0xsetting, 0x
{0x548b, 0xb2}, //Y, 0xGamma, 0xsetting, 0x
{0x548c, 0xc8}, //Y, 0xGamma, 0xsetting, 0x
{0x548d, 0xd9}, //Y, 0xGamma, 0xsetting, 0x
{0x548e, 0xec}, //Y, 0xGamma, 0xsetting, 0x

//UV, 0xGamma
{0x5490, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x5491, 0xc0}, //UV, 0xGamma, 0xsetting, 0x
{0x5492, 0x03}, //UV, 0xGamma, 0xsetting, 0x
{0x5493, 0x00}, //UV, 0xGamma, 0xsetting, 0x
{0x5494, 0x03}, //UV, 0xGamma, 0xsetting, 0x
{0x5495, 0xe0}, //UV, 0xGamma, 0xsetting, 0x
{0x5496, 0x03}, //UV, 0xGamma, 0xsetting, 0x
{0x5497, 0x10}, //UV, 0xGamma, 0xsetting, 0x
{0x5498, 0x02}, //UV, 0xGamma, 0xsetting, 0x
{0x5499, 0xac}, //UV, 0xGamma, 0xsetting, 0x
{0x549a, 0x02}, //UV, 0xGamma, 0xsetting, 0x
{0x549b, 0x75}, //UV, 0xGamma, 0xsetting, 0x
{0x549c, 0x02}, //UV, 0xGamma, 0xsetting, 0x
{0x549d, 0x44}, //UV, 0xGamma, 0xsetting, 0x
{0x549e, 0x02}, //UV, 0xGamma, 0xsetting, 0x
{0x549f, 0x20}, //UV, 0xGamma, 0xsetting, 0x
{0x54a0, 0x02}, //UV, 0xGamma, 0xsetting, 0x
{0x54a1, 0x07}, //UV, 0xGamma, 0xsetting, 0x
{0x54a2, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x54a3, 0xec}, //UV, 0xGamma, 0xsetting, 0x
{0x54a4, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x54a5, 0xc0}, //UV, 0xGamma, 0xsetting, 0x
{0x54a6, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x54a7, 0x9b}, //UV, 0xGamma, 0xsetting, 0x
{0x54a8, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x54a9, 0x63}, //UV, 0xGamma, 0xsetting, 0x
{0x54aa, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x54ab, 0x2b}, //UV, 0xGamma, 0xsetting, 0x
{0x54ac, 0x01}, //UV, 0xGamma, 0xsetting, 0x
{0x54ad, 0x22}, //UV, 0xGamma, 0xsetting, 0x

//, 0xUV, 0xadjust
{0x5501, 0x1c}, //UV, 0xadjust, 0xsetting, 0x
{0x5502, 0x00}, //UV, 0xadjust, 0xsetting, 0x
{0x5503, 0x40}, //UV, 0xadjust, 0xsetting, 0x
{0x5504, 0x00}, //UV, 0xadjust, 0xsetting, 0x
{0x5505, 0x80}, //UV, 0xadjust, 0xsetting, 0x

//, 0xLens, 0xcorrection
{0x5800, 0x1c}, //Lens, 0xcorrection, 0xsetting
{0x5801, 0x16}, //Lens, 0xcorrection, 0xsetting
{0x5802, 0x15}, //Lens, 0xcorrection, 0xsetting
{0x5803, 0x16}, //Lens, 0xcorrection, 0xsetting
{0x5804, 0x18}, //Lens, 0xcorrection, 0xsetting
{0x5805, 0x1a}, //Lens, 0xcorrection, 0xsetting
{0x5806, 0x0c}, //Lens, 0xcorrection, 0xsetting
{0x5807, 0x0a}, //Lens, 0xcorrection, 0xsetting
{0x5808, 0x08}, //Lens, 0xcorrection, 0xsetting
{0x5809, 0x08}, //Lens, 0xcorrection, 0xsetting
{0x580a, 0x0a}, //Lens, 0xcorrection, 0xsetting
{0x580b, 0x0b}, //Lens, 0xcorrection, 0xsetting
{0x580c, 0x05}, //Lens, 0xcorrection, 0xsetting
{0x580d, 0x02}, //Lens, 0xcorrection, 0xsetting
{0x580e, 0x00}, //Lens, 0xcorrection, 0xsetting
{0x580f, 0x00}, //Lens, 0xcorrection, 0xsetting
{0x5810, 0x02}, //Lens, 0xcorrection, 0xsetting
{0x5811, 0x05}, //Lens, 0xcorrection, 0xsetting
{0x5812, 0x04}, //Lens, 0xcorrection, 0xsetting
{0x5813, 0x01}, //Lens, 0xcorrection, 0xsetting
{0x5814, 0x00}, //Lens, 0xcorrection, 0xsetting
{0x5815, 0x00}, //Lens, 0xcorrection, 0xsetting
{0x5816, 0x02}, //Lens, 0xcorrection, 0xsetting
{0x5817, 0x03}, //Lens, 0xcorrection, 0xsetting
{0x5818, 0x0a}, //Lens, 0xcorrection, 0xsetting
{0x5819, 0x07}, //Lens, 0xcorrection, 0xsetting
{0x581a, 0x05}, //Lens, 0xcorrection, 0xsetting
{0x581b, 0x05}, //Lens, 0xcorrection, 0xsetting
{0x581c, 0x08}, //Lens, 0xcorrection, 0xsetting
{0x581d, 0x0b}, //Lens, 0xcorrection, 0xsetting
{0x581e, 0x15}, //Lens, 0xcorrection, 0xsetting
{0x581f, 0x14}, //Lens, 0xcorrection, 0xsetting
{0x5820, 0x14}, //Lens, 0xcorrection, 0xsetting
{0x5821, 0x13}, //Lens, 0xcorrection, 0xsetting
{0x5822, 0x17}, //Lens, 0xcorrection, 0xsetting
{0x5823, 0x16}, //Lens, 0xcorrection, 0xsetting
{0x5824, 0x46}, //Lens, 0xcorrection, 0xsetting
{0x5825, 0x4c}, //Lens, 0xcorrection, 0xsetting
{0x5826, 0x6c}, //Lens, 0xcorrection, 0xsetting
{0x5827, 0x4c}, //Lens, 0xcorrection, 0xsetting
{0x5828, 0x80}, //Lens, 0xcorrection, 0xsetting
{0x5829, 0x2e}, //Lens, 0xcorrection, 0xsetting
{0x582a, 0x48}, //Lens, 0xcorrection, 0xsetting
{0x582b, 0x46}, //Lens, 0xcorrection, 0xsetting
{0x582c, 0x2a}, //Lens, 0xcorrection, 0xsetting
{0x582d, 0x68}, //Lens, 0xcorrection, 0xsetting
{0x582e, 0x08}, //Lens, 0xcorrection, 0xsetting
{0x582f, 0x26}, //Lens, 0xcorrection, 0xsetting
{0x5830, 0x44}, //Lens, 0xcorrection, 0xsetting
{0x5831, 0x46}, //Lens, 0xcorrection, 0xsetting
{0x5832, 0x62}, //Lens, 0xcorrection, 0xsetting
{0x5833, 0x0c}, //Lens, 0xcorrection, 0xsetting
{0x5834, 0x28}, //Lens, 0xcorrection, 0xsetting
{0x5835, 0x46}, //Lens, 0xcorrection, 0xsetting
{0x5836, 0x28}, //Lens, 0xcorrection, 0xsetting
{0x5837, 0x88}, //Lens, 0xcorrection, 0xsetting
{0x5838, 0x0e}, //Lens, 0xcorrection, 0xsetting
{0x5839, 0x0e}, //Lens, 0xcorrection, 0xsetting
{0x583a, 0x2c}, //Lens, 0xcorrection, 0xsetting
{0x583b, 0x2e}, //Lens, 0xcorrection, 0xsetting
{0x583c, 0x46}, //Lens, 0xcorrection, 0xsetting
{0x583d, 0xca}, //Lens, 0xcorrection, 0xsetting
{0x583e, 0xf0}, //Lens, 0xcorrection, 0xsetting
{0x5842, 0x02}, //Lens, 0xcorrection, 0xsetting
{0x5843, 0x5e}, //Lens, 0xcorrection, 0xsetting
{0x5844, 0x04}, //Lens, 0xcorrection, 0xsetting
{0x5845, 0x32}, //Lens, 0xcorrection, 0xsetting
{0x5846, 0x03}, //Lens, 0xcorrection, 0xsetting
{0x5847, 0x29}, //Lens, 0xcorrection, 0xsetting
{0x5848, 0x02}, //Lens, 0xcorrection, 0xsetting
{0x5849, 0xcc}, //Lens, 0xcorrection, 0xsetting

//, 0xStart, 0xstreaming
{0x0100, 0x01}, //start, 0xstreaming
    
	{OV9740_TABLE_WAIT_MS, 100}, 
	{OV9740_TABLE_END, 0x00}
};

static struct ov9740_reg mode_960x720[] ={ 
	{OV9740_TABLE_WAIT_MS, 100}, 
		//, 0xSoftware, 0xRESET
	{0x0103, 0x01},
	//Orientation
	{0x0101, 0x01},
	
	//PLL, 0xsetting
	{0x3104, 0x20},
	{0x0305, 0x03},
	{0x0307, 0x4c},
	{0x0303, 0x01},
	{0x0301, 0x08},
	{0x3010, 0x01},
	
	//Timing, 0xsetting
	{0x0340, 0x03},
	{0x0341, 0x07},
	{0x0342, 0x06},
	{0x0343, 0x62},
	{0x0344, 0x00},
	{0x0345, 0x08},
	{0x0346, 0x00},
	{0x0347, 0x04},
	{0x0348, 0x05},
	{0x0349, 0x0c},
	{0x034a, 0x02},
	{0x034b, 0xd8},
	{0x034c, 0x03},
	{0x034d, 0xc0},
	{0x034e, 0x02},
	{0x034f, 0xd0},
	
	//Output, 0xselect
	{0x3002, 0x00},
	{0x3004, 0x00},
	{0x3005, 0x00},
	{0x3012, 0x70},
	{0x3013, 0x60},
	{0x3014, 0x01},
	{0x301f, 0x03},
	{0x3026, 0x00},
	{0x3027, 0x00},
	
	//Analog, 0xcontrol
	{0x3601, 0x40},
	{0x3602, 0x16},
	{0x3603, 0xaa},
	{0x3604, 0x0c},
	{0x3610, 0xa1},
	{0x3612, 0x24},
	{0x3620, 0x66},
	{0x3621, 0xc0},
	{0x3622, 0x9f},
	{0x3630, 0xd2},
	{0x3631, 0x5e},
	{0x3632, 0x27},
	{0x3633, 0x50},
	
	//Sensor, 0xcontrol
	{0x3703, 0x42},
	{0x3704, 0x10},
	{0x3705, 0x45},
	{0x3707, 0x11},
	
	//Timing, 0xcontrol
	{0x3817, 0x94},
	{0x3819, 0x6e},
	{0x3831, 0x40},
	{0x3833, 0x04},
	{0x3835, 0x04},
	{0x3837, 0x01},
	
	//AEC/AGC, 0xcontrol
	{0x3503, 0x10},
	{0x3a18, 0x01},
	{0x3a19, 0xB5},
	{0x3a1a, 0x05},
	{0x3a11, 0x90},
	{0x3a1b, 0x4a},
	{0x3a0f, 0x48},
	{0x3a10, 0x44},
	{0x3a1e, 0x42},
	{0x3a1f, 0x22},
	
	//Banding, 0xfilter
	{0x3a08, 0x00},
	{0x3a09, 0xe8},
	{0x3a0e, 0x03},
	{0x3a14, 0x15},
	{0x3a15, 0xc6},
	{0x3a0a, 0x00},
	{0x3a0b, 0xc0},
	{0x3a0d, 0x04},
	{0x3a02, 0x18},
	{0x3a03, 0x20},
	
	//50/60, 0xdetection
	{0x3c0a, 0x9c},
	{0x3c0b, 0x3f},
	
	//BLC, 0xcontrol
	{0x4002, 0x45},
	{0x4005, 0x18},
	
	//VFIFO, 0xcontrol
	{0x4601, 0x16},
	{0x460e, 0x82},
	
	//YVYU
	{0x4300,0x32},
	
	//DVP, 0xcontrol
	{0x4702, 0x04},
	{0x4704, 0x00},
	{0x4706, 0x08},
	
	//MIPI, 0xcontrol
	{0x4800, 0x44},
	{0x4801, 0x0f},
	{0x4803, 0x05},
	{0x4805, 0x10},
	{0x4837, 0x20},
	
	//ISP, 0xcontrol
	{0x5000, 0xff},
	{0x5001, 0xff},
	{0x5003, 0xff},
	
	//AWB
	{0x5180, 0xf0},
	{0x5181, 0x00},
	{0x5182, 0x41},
	{0x5183, 0x42},
	{0x5184, 0x80},
	{0x5185, 0x68},
	{0x5186, 0x93},
	{0x5187, 0xa8},
	{0x5188, 0x17},
	{0x5189, 0x45},
	{0x518a, 0x27},
	{0x518b, 0x41},
	{0x518c, 0x2d},
	{0x518d, 0xf0},
	{0x518e, 0x10},
	{0x518f, 0xff},
	{0x5190, 0x0},
	{0x5191, 0xff},
	{0x5192, 0x00},
	{0x5193, 0xff},
	{0x5194, 0x00},
	
	//DNS
	{0x529a, 0x02},
	{0x529b, 0x08},
	{0x529c, 0x0a},
	{0x529d, 0x10},
	{0x529e, 0x10},
	{0x529f, 0x28},
	{0x52a0, 0x32},
	{0x52a2, 0x00},
	{0x52a3, 0x02},
	{0x52a4, 0x00},
	{0x52a5, 0x04},
	{0x52a6, 0x00},
	{0x52a7, 0x08},
	{0x52a8, 0x00},
	{0x52a9, 0x10},
	{0x52aa, 0x00},
	{0x52ab, 0x38},
	{0x52ac, 0x00},
	{0x52ad, 0x3c},
	{0x52ae, 0x00},
	{0x52af, 0x4c},
	
	//CIP
	{0x530d, 0x06},
	
	//CMX
	{0x5380, 0x01},
	{0x5381, 0x00},
	{0x5382, 0x00},
	{0x5383, 0x0d},
	{0x5384, 0x00},
	{0x5385, 0x2f},
	{0x5386, 0x00},
	{0x5387, 0x00},
	{0x5388, 0x00},
	{0x5389, 0xd3},
	{0x538a, 0x00},
	{0x538b, 0x0f},
	{0x538c, 0x00},
	{0x538d, 0x00},
	{0x538e, 0x00},
	{0x538f, 0x32},
	{0x5390, 0x00},
	{0x5391, 0x94},
	{0x5392, 0x00},
	{0x5393, 0xa4},
	{0x5394, 0x18},
	
	//Contrast
	{0x5401, 0x2c},
	{0x5403, 0x28},
	{0x5404, 0x06},
	{0x5405, 0xe0},
	
	//Y, 0xGamma
	{0x5480, 0x04},
	{0x5481, 0x12},
	{0x5482, 0x27},
	{0x5483, 0x49},
	{0x5484, 0x57},
	{0x5485, 0x66},
	{0x5486, 0x75},
	{0x5487, 0x81},
	{0x5488, 0x8c},
	{0x5489, 0x95},
	{0x548a, 0xa5},
	{0x548b, 0xb2},
	{0x548c, 0xc8},
	{0x548d, 0xd9},
	{0x548e, 0xec},
	
	//UV, 0xGamma
	{0x5490, 0x01},
	{0x5491, 0xc0},
	{0x5492, 0x03},
	{0x5493, 0x00},
	{0x5494, 0x03},
	{0x5495, 0xe0},
	{0x5496, 0x03},
	{0x5497, 0x10},
	{0x5498, 0x02},
	{0x5499, 0xac},
	{0x549a, 0x02},
	{0x549b, 0x75},
	{0x549c, 0x02},
	{0x549d, 0x44},
	{0x549e, 0x02},
	{0x549f, 0x20},
	{0x54a0, 0x02},
	{0x54a1, 0x07},
	{0x54a2, 0x01},
	{0x54a3, 0xec},
	{0x54a4, 0x01},
	
	//UV, 0xadjust
	{0x5501, 0x1c},
	{0x5502, 0x00},
	{0x5503, 0x40},
	{0x5504, 0x00},
	{0x5505, 0x80},
	
	//Lens, 0xcorrection
	{0x5800, 0x1c},
	{0x5801, 0x16},
	{0x5802, 0x15},
	{0x5803, 0x16},
	{0x5804, 0x18},
	{0x5805, 0x1a},
	{0x5806, 0x0c},
	{0x5807, 0x0a},
	{0x5808, 0x08},
	{0x5809, 0x08},
	{0x580a, 0x0a},
	{0x580b, 0x0b},
	{0x580c, 0x05},
	{0x580d, 0x02},
	{0x580e, 0x00},
	{0x580f, 0x00},
	{0x5810, 0x02},
	{0x5811, 0x05},
	{0x5812, 0x04},
	{0x5813, 0x01},
	{0x5814, 0x00},
	{0x5815, 0x00},
	{0x5816, 0x02},
	{0x5817, 0x03},
	{0x5818, 0x0a},
	{0x5819, 0x07},
	{0x581a, 0x05},
	{0x581b, 0x05},
	{0x581c, 0x08},
	{0x581d, 0x0b},
	{0x581e, 0x15},
	{0x581f, 0x14},
	{0x5820, 0x14},
	{0x5821, 0x13},
	{0x5822, 0x17},
	{0x5823, 0x16},
	{0x5824, 0x46},
	{0x5825, 0x4c},
	{0x5826, 0x6c},
	{0x5827, 0x4c},
	{0x5828, 0x80},
	{0x5829, 0x2e},
	{0x582a, 0x48},
	{0x582b, 0x46},
	{0x582c, 0x2a},
	{0x582d, 0x68},
	{0x582e, 0x08},
	{0x582f, 0x26},
	{0x5830, 0x44},
	{0x5831, 0x46},
	{0x5832, 0x62},
	{0x5833, 0x0c},
	{0x5834, 0x28},
	{0x5835, 0x46},
	{0x5836, 0x28},
	{0x5837, 0x88},
	{0x5838, 0x0e},
	{0x5839, 0x0e},
	{0x583a, 0x2c},
	{0x583b, 0x2e},
	{0x583c, 0x46},
	{0x583d, 0xca},
	{0x54a5, 0xc0},
	{0x54a6, 0x01},
	{0x54a7, 0x9b},
	{0x54a8, 0x01},
	{0x54a9, 0x63},
	{0x54aa, 0x01},
	{0x54ab, 0x2b},
	{0x54ac, 0x01},
	{0x54ad, 0x22},
	{0x583e, 0xf0},
	{0x5842, 0x02},
	{0x5843, 0x5e},
	{0x5844, 0x04},
	{0x5845, 0x32},
	{0x5846, 0x03},
	{0x5847, 0x29},
	{0x5848, 0x02},
	{0x5849, 0xcc},
	
	//Start streaming
	{0x0100, 0x01},
	
	{OV9740_TABLE_WAIT_MS, 100}, 
	{OV9740_TABLE_END, 0x00}
}; 

static struct ov9740_reg mode_1280x720[] = { 
	{OV9740_TABLE_WAIT_MS, 100}, 
		//, 0xSoftware, 0xRESET
	{0x0103, 0x01},
	//Orientation
	{0x0101, 0x01},
	
	//PLL, 0xsetting
	{0x3104, 0x20},
	{0x0305, 0x03},
	{0x0307, 0x4c},
	{0x0303, 0x01},
	{0x0301, 0x08},
	{0x3010, 0x01},
	
	//Timing, 0xsetting
	{0x0340, 0x03},
	{0x0341, 0x07},
	{0x0342, 0x06},
	{0x0343, 0x62},
	{0x0344, 0x00},
	{0x0345, 0x08},
	{0x0346, 0x00},
	{0x0347, 0x04},
	{0x0348, 0x05},
	{0x0349, 0x0c},
	{0x034a, 0x02},
	{0x034b, 0xd8},
	{0x034c, 0x05},
	{0x034d, 0x00},
	{0x034e, 0x02},
	{0x034f, 0xd0},
	
	//Output, 0xselect
	{0x3002, 0x00},
	{0x3004, 0x00},
	{0x3005, 0x00},
	{0x3012, 0x70},
	{0x3013, 0x60},
	{0x3014, 0x01},
	{0x301f, 0x03},
	{0x3026, 0x00},
	{0x3027, 0x00},
	
	//Analog, 0xcontrol
	{0x3601, 0x40},
	{0x3602, 0x16},
	{0x3603, 0xaa},
	{0x3604, 0x0c},
	{0x3610, 0xa1},
	{0x3612, 0x24},
	{0x3620, 0x66},
	{0x3621, 0xc0},
	{0x3622, 0x9f},
	{0x3630, 0xd2},
	{0x3631, 0x5e},
	{0x3632, 0x27},
	{0x3633, 0x50},
	
	//Sensor, 0xcontrol
	{0x3703, 0x42},
	{0x3704, 0x10},
	{0x3705, 0x45},
	{0x3707, 0x11},
	
	//Timing, 0xcontrol
	{0x3817, 0x94},
	{0x3819, 0x6e},
	{0x3831, 0x40},
	{0x3833, 0x04},
	{0x3835, 0x04},
	{0x3837, 0x01},
	
	//AEC/AGC, 0xcontrol
	{0x3503, 0x10},
	{0x3a18, 0x01},
	{0x3a19, 0xB5},
	{0x3a1a, 0x05},
	{0x3a11, 0x90},
	{0x3a1b, 0x4a},
	{0x3a0f, 0x48},
	{0x3a10, 0x44},
	{0x3a1e, 0x42},
	{0x3a1f, 0x22},
	
	//Banding, 0xfilter
	{0x3a08, 0x00},
	{0x3a09, 0xe8},
	{0x3a0e, 0x03},
	{0x3a14, 0x15},
	{0x3a15, 0xc6},
	{0x3a0a, 0x00},
	{0x3a0b, 0xc0},
	{0x3a0d, 0x04},
	{0x3a02, 0x18},
	{0x3a03, 0x20},
	
	//50/60, 0xdetection
	{0x3c0a, 0x9c},
	{0x3c0b, 0x3f},
	
	//BLC, 0xcontrol
	{0x4002, 0x45},
	{0x4005, 0x18},
	
	//VFIFO, 0xcontrol
	{0x4601, 0x16},
	{0x460e, 0x82},
	
	//YVYU
	{0x4300,0x32},
	
	//DVP, 0xcontrol
	{0x4702, 0x04},
	{0x4704, 0x00},
	{0x4706, 0x08},
	
	//MIPI, 0xcontrol
	{0x4800, 0x44},
	{0x4801, 0x0f},
	{0x4803, 0x05},
	{0x4805, 0x10},
	{0x4837, 0x20},
	
	//ISP, 0xcontrol
	{0x5000, 0xff},
	{0x5001, 0xff},
	{0x5003, 0xff},
	
	//AWB
	{0x5180, 0xf0},
	{0x5181, 0x00},
	{0x5182, 0x41},
	{0x5183, 0x42},
	{0x5184, 0x80},
	{0x5185, 0x68},
	{0x5186, 0x93},
	{0x5187, 0xa8},
	{0x5188, 0x17},
	{0x5189, 0x45},
	{0x518a, 0x27},
	{0x518b, 0x41},
	{0x518c, 0x2d},
	{0x518d, 0xf0},
	{0x518e, 0x10},
	{0x518f, 0xff},
	{0x5190, 0x0},
	{0x5191, 0xff},
	{0x5192, 0x00},
	{0x5193, 0xff},
	{0x5194, 0x00},
	
	//DNS
	{0x529a, 0x02},
	{0x529b, 0x08},
	{0x529c, 0x0a},
	{0x529d, 0x10},
	{0x529e, 0x10},
	{0x529f, 0x28},
	{0x52a0, 0x32},
	{0x52a2, 0x00},
	{0x52a3, 0x02},
	{0x52a4, 0x00},
	{0x52a5, 0x04},
	{0x52a6, 0x00},
	{0x52a7, 0x08},
	{0x52a8, 0x00},
	{0x52a9, 0x10},
	{0x52aa, 0x00},
	{0x52ab, 0x38},
	{0x52ac, 0x00},
	{0x52ad, 0x3c},
	{0x52ae, 0x00},
	{0x52af, 0x4c},
	
	//CIP
	{0x530d, 0x06},
	
	//CMX
	{0x5380, 0x01},
	{0x5381, 0x00},
	{0x5382, 0x00},
	{0x5383, 0x0d},
	{0x5384, 0x00},
	{0x5385, 0x2f},
	{0x5386, 0x00},
	{0x5387, 0x00},
	{0x5388, 0x00},
	{0x5389, 0xd3},
	{0x538a, 0x00},
	{0x538b, 0x0f},
	{0x538c, 0x00},
	{0x538d, 0x00},
	{0x538e, 0x00},
	{0x538f, 0x32},
	{0x5390, 0x00},
	{0x5391, 0x94},
	{0x5392, 0x00},
	{0x5393, 0xa4},
	{0x5394, 0x18},
	
	//Contrast
	{0x5401, 0x2c},
	{0x5403, 0x28},
	{0x5404, 0x06},
	{0x5405, 0xe0},
	
	//Y, 0xGamma
	{0x5480, 0x04},
	{0x5481, 0x12},
	{0x5482, 0x27},
	{0x5483, 0x49},
	{0x5484, 0x57},
	{0x5485, 0x66},
	{0x5486, 0x75},
	{0x5487, 0x81},
	{0x5488, 0x8c},
	{0x5489, 0x95},
	{0x548a, 0xa5},
	{0x548b, 0xb2},
	{0x548c, 0xc8},
	{0x548d, 0xd9},
	{0x548e, 0xec},
	
	//UV, 0xGamma
	{0x5490, 0x01},
	{0x5491, 0xc0},
	{0x5492, 0x03},
	{0x5493, 0x00},
	{0x5494, 0x03},
	{0x5495, 0xe0},
	{0x5496, 0x03},
	{0x5497, 0x10},
	{0x5498, 0x02},
	{0x5499, 0xac},
	{0x549a, 0x02},
	{0x549b, 0x75},
	{0x549c, 0x02},
	{0x549d, 0x44},
	{0x549e, 0x02},
	{0x549f, 0x20},
	{0x54a0, 0x02},
	{0x54a1, 0x07},
	{0x54a2, 0x01},
	{0x54a3, 0xec},
	{0x54a4, 0x01},
	
	//UV, 0xadjust
	{0x5501, 0x1c},
	{0x5502, 0x00},
	{0x5503, 0x40},
	{0x5504, 0x00},
	{0x5505, 0x80},
	
	//Lens, 0xcorrection
	{0x5800, 0x1c},
	{0x5801, 0x16},
	{0x5802, 0x15},
	{0x5803, 0x16},
	{0x5804, 0x18},
	{0x5805, 0x1a},
	{0x5806, 0x0c},
	{0x5807, 0x0a},
	{0x5808, 0x08},
	{0x5809, 0x08},
	{0x580a, 0x0a},
	{0x580b, 0x0b},
	{0x580c, 0x05},
	{0x580d, 0x02},
	{0x580e, 0x00},
	{0x580f, 0x00},
	{0x5810, 0x02},
	{0x5811, 0x05},
	{0x5812, 0x04},
	{0x5813, 0x01},
	{0x5814, 0x00},
	{0x5815, 0x00},
	{0x5816, 0x02},
	{0x5817, 0x03},
	{0x5818, 0x0a},
	{0x5819, 0x07},
	{0x581a, 0x05},
	{0x581b, 0x05},
	{0x581c, 0x08},
	{0x581d, 0x0b},
	{0x581e, 0x15},
	{0x581f, 0x14},
	{0x5820, 0x14},
	{0x5821, 0x13},
	{0x5822, 0x17},
	{0x5823, 0x16},
	{0x5824, 0x46},
	{0x5825, 0x4c},
	{0x5826, 0x6c},
	{0x5827, 0x4c},
	{0x5828, 0x80},
	{0x5829, 0x2e},
	{0x582a, 0x48},
	{0x582b, 0x46},
	{0x582c, 0x2a},
	{0x582d, 0x68},
	{0x582e, 0x08},
	{0x582f, 0x26},
	{0x5830, 0x44},
	{0x5831, 0x46},
	{0x5832, 0x62},
	{0x5833, 0x0c},
	{0x5834, 0x28},
	{0x5835, 0x46},
	{0x5836, 0x28},
	{0x5837, 0x88},
	{0x5838, 0x0e},
	{0x5839, 0x0e},
	{0x583a, 0x2c},
	{0x583b, 0x2e},
	{0x583c, 0x46},
	{0x583d, 0xca},
	{0x54a5, 0xc0},
	{0x54a6, 0x01},
	{0x54a7, 0x9b},
	{0x54a8, 0x01},
	{0x54a9, 0x63},
	{0x54aa, 0x01},
	{0x54ab, 0x2b},
	{0x54ac, 0x01},
	{0x54ad, 0x22},
	{0x583e, 0xf0},
	{0x5842, 0x02},
	{0x5843, 0x5e},
	{0x5844, 0x04},
	{0x5845, 0x32},
	{0x5846, 0x03},
	{0x5847, 0x29},
	{0x5848, 0x02},
	{0x5849, 0xcc},
	
	//Start streaming
	{0x0100, 0x01},
	
	{OV9740_TABLE_WAIT_MS, 100}, 
	{OV9740_TABLE_END, 0x00}
}; 


enum {
	OV9740_MODE_1280x720,
	OV9740_MODE_960x720,
	OV9740_MODE_640x480,
};

static struct ov9740_reg *mode_table[] = {
	[OV9740_MODE_1280x720] = mode_1280x720,
	[OV9740_MODE_640x480] = mode_640x480,
	[OV9740_MODE_960x720] = mode_960x720,
};


static inline void
msleep_range(unsigned int delay_base)
{
	usleep_range(delay_base*1000, delay_base*1000+500);
}

static int
ov9740_read_reg(struct i2c_client *client, u16 addr, u8 *val)
{
	int err;
	struct i2c_msg msg[2];
	unsigned char data[3];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len = 1;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)
		return -EINVAL;

	*val = data[2];

	return 0;
}

static int
ov9740_write_reg(struct i2c_client *client, u16 addr, u8 val)
{
	int err;
	struct i2c_msg msg;
	unsigned char data[3];

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);
	data[2] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 3;
	msg.buf = data;

	err = i2c_transfer(client->adapter, &msg, 1);
	if (err == 1)
		return 0;

	dev_err(&client->dev, "%s:i2c write failed, %x = %x\n",
			__func__, addr, val);

	return err;
}

static int
ov9740_write_table(struct i2c_client *client,
			 const struct ov9740_reg table[],
			 const struct ov9740_reg override_list[],
			 int num_override_regs)
{
	int err;
	const struct ov9740_reg *next;
	int i;
	u16 val;

	for (next = table; next->addr != OV9740_TABLE_END; next++) {
		if (next->addr == OV9740_TABLE_WAIT_MS) {
			msleep_range(next->val);
			continue;
		}

		val = next->val;

		/*
		 * When an override list is passed in, replace the reg
		 * value to write if the reg is in the list
		 */
		if (override_list) {
			for (i = 0; i < num_override_regs; i++) {
				if (next->addr == override_list[i].addr) {
					val = override_list[i].val;
					break;
				}
			}
		}

		err = ov9740_write_reg(client, next->addr, val);
		if (err) {
			dev_err(&client->dev, "%s:ov9740_write_table:%d",
				__func__, err);
			return err;
		}
	}
	return 0;
}

static int
ov9740_set_mode(struct ov9740_info *info, struct ov9740_mode *mode)
{
	struct device *dev = &info->i2c_client->dev;
	int sensor_mode;
	int err;

	printk("%s: resolution supplied to set mode %d %d\n", __func__, mode->xres, mode->yres);

	if (mode->xres == 1280 && mode->yres == 720)
		sensor_mode = OV9740_MODE_1280x720;
	else if (mode->xres == 640 && mode->yres == 480)
		sensor_mode = OV9740_MODE_640x480;
	else if (mode->xres == 960 && mode->yres == 720)
		sensor_mode = OV9740_MODE_960x720;
	else {
		dev_err(dev, "%s: invalid resolution to set mode %d %d\n",
			__func__, mode->xres, mode->yres);
		return -EINVAL;
	}

	err = ov9740_write_table(info->i2c_client, mode_table[sensor_mode], NULL, 0);
	if (err)
		return err;

	msleep(100);

	info->mode = sensor_mode;
	dev_info(dev, "[ov9740]: stream on.\n");
	return 0;
}

static int
ov9740_get_status(struct ov9740_info *info, u8 *dev_status)
{
	return 0;
}

static long
ov9740_ioctl(struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	int err = 0;
	struct ov9740_info *info = file->private_data;
	struct device *dev = &info->i2c_client->dev;

	switch (cmd) {
	case OV9740_IOCTL_SET_MODE:
	{
		struct ov9740_mode mode;
		if (copy_from_user(&mode,
			(const void __user *)arg,
			sizeof(struct ov9740_mode))) {
			dev_err(dev, "%s:Failed to get mode from user.\n",
			__func__);
			return -EFAULT;
		}
		return ov9740_set_mode(info, &mode);
	}

	case OV9740_IOCTL_GET_STATUS:
	{
		u8 status;

		err = ov9740_get_status(info, &status);
		if (err)
			return err;
		if (copy_to_user((void __user *)arg, &status, 2)) {
			dev_err(dev, "%s:Failed to copy status to user.\n",
			__func__);
			return -EFAULT;
		}
		return 0;
	}
	case OV9740_IOCTL_SET_BRIGHTNESS:
		{
			u8 brightness;
			if (copy_from_user(&brightness,
				(const void __user *)arg,
				sizeof(brightness))) {
				return -EFAULT;
			}
			
			switch(brightness)
			{
			case OV9740_Brightness_Level1:
				printk("yuv SET_Brightness 0\n");
				err = ov9740_write_table(info->i2c_client, ov9740_brightness_level1,NULL, 0);
				break;
				
			case OV9740_Brightness_Level2:
				printk("yuv SET_Brightness 1\n");
				err = ov9740_write_table(info->i2c_client, ov9740_brightness_level2,NULL, 0);
				break;
				
			case OV9740_Brightness_Level3:
				printk("yuv SET_Brightness 2\n");
				err = ov9740_write_table(info->i2c_client, ov9740_brightness_level3,NULL, 0);
				break;
				
			case OV9740_Brightness_Level4:
				printk("yuv SET_Brightness 3\n");
				err = ov9740_write_table(info->i2c_client, ov9740_brightness_level4,NULL, 0);
				break;
				
			case OV9740_Brightness_Level5:
				printk("yuv SET_Brightness 4\n");
				err = ov9740_write_table(info->i2c_client, ov9740_brightness_level5,NULL, 0);
				break;
				
			case OV9740_Brightness_Level6:
				printk("yuv SET_Brightness 4\n");
				err = ov9740_write_table(info->i2c_client, ov9740_brightness_level6,NULL, 0);
				break;
			default:
				break;
			}
			if(err)
				return err;
			return 0;
			
		}
	case OV9740_IOCTL_SET_WHITE_BALANCE:
		{
			u8 whitebalance;
			
			pr_info("yuv whitebalance %lu\n",arg);
			if (copy_from_user(&whitebalance,
				(const void __user *)arg,
				sizeof(whitebalance))) {
				return -EFAULT;
			}
						
			switch(whitebalance)
			{
			case OV9740_Whitebalance_Auto:
				err = ov9740_write_table(info->i2c_client, Whitebalance_Auto,NULL, 0);
				break;
			case OV9740_Whitebalance_Incandescent:
				err = ov9740_write_table(info->i2c_client, Whitebalance_Incandescent,NULL, 0);
				break;
			case OV9740_Whitebalance_Daylight:
				err = ov9740_write_table(info->i2c_client, Whitebalance_Daylight,NULL, 0);
				break;
			case OV9740_Whitebalance_Fluorescent:
				err = ov9740_write_table(info->i2c_client, Whitebalance_Fluorescent,NULL, 0);
				break;
			case OV9740_Whitebalance_Cloudy:
				err = ov9740_write_table(info->i2c_client, Whitebalance_Cloudy,NULL, 0);
				break;
			default:
				break;
			}
			if (err)
				return err;
			return 0;
		}
	case OV9740_IOCTL_SET_CONTRAST:	
		{
			int contrast;
			
			if (copy_from_user(&contrast,
				(const void __user *)arg,
				sizeof(contrast))) {
				return -EFAULT;
			}
			
			printk("yuv SET_Contrast  contrast=%d\n",contrast);
			
			switch(contrast)
			{
			case OV9740_Contrast_Level1:
				printk("yuv SET_Contrast -50\n");
				err = ov9740_write_table(info->i2c_client, ov9740_contrast_level1,NULL, 0);
				break;
			case OV9740_Contrast_Level2:
				printk("yuv SET_Contrast -100\n");
				err = ov9740_write_table(info->i2c_client, ov9740_contrast_level2,NULL, 0);
				break;
			case OV9740_Contrast_Level3:
				printk("yuv SET_Contrast 0\n");
				err = ov9740_write_table(info->i2c_client, ov9740_contrast_level3,NULL, 0);
				break;
			case OV9740_Contrast_Level4:
				printk("yuv SET_Contrast 50\n");
				err = ov9740_write_table(info->i2c_client, ov9740_contrast_level4,NULL, 0);
				break;
			case OV9740_Contrast_Level5:
				printk("yuv SET_Contrast 100\n");
				err = ov9740_write_table(info->i2c_client, ov9740_contrast_level5,NULL, 0);
				break;
			default:
				break;
			}
			
			if(err)
				return err;
			return 0;
		}
	case OV9740_IOCTL_SET_COLOR_EFFECT:
		{
			int effect;
			
			if (copy_from_user(&effect,
				(const void __user *)arg,
				sizeof(effect))) {
				return -EFAULT;
			}
			
			//printk("yuv SET_Contrast  contrast=%d,%d\n",contrast,ov5640_contrast);
			
			switch(effect)
			{
			case OV9740_ColorEffect_None:
				printk("OV9740_ColorEffect_None\n");
				err = ov9740_write_table(info->i2c_client, ColorEffect_None,NULL, 0);
				break;
			case OV9740_ColorEffect_Mono:
				printk("OV9740_ColorEffect_Mono\n");
				err = ov9740_write_table(info->i2c_client, ColorEffect_Mono,NULL, 0);
				break;
			case OV9740_ColorEffect_Sepia:
				printk("OV9740_ColorEffect_Sepia\n");
				err = ov9740_write_table(info->i2c_client, ColorEffect_Sepia,NULL, 0);
				break;
			case OV9740_ColorEffect_Negative:
				printk("OV9740_ColorEffect_Negative\n");
				err = ov9740_write_table(info->i2c_client, ColorEffect_Negative,NULL, 0);
				break;
			case OV9740_ColorEffect_Aqua:
				printk("OV9740_ColorEffect_Aqua\n");
				err = ov9740_write_table(info->i2c_client, ColorEffect_Bluish,NULL, 0);
				break;
			default:
				break;
			}
			
			if(err)
				return err;
			return 0;
		}
	
	default:
		dev_err(dev, "%s:unknown cmd.\n", __func__);
		return -EINVAL;
	}
	return 0;
}

static int
ov9740_open(struct inode *inode, struct file *file)
{
	struct miscdevice	*miscdev = file->private_data;
	struct ov9740_info	*info;

	info = container_of(miscdev, struct ov9740_info, miscdev_info);
	/* check if the device is in use */
	if (atomic_xchg(&info->in_use, 1)) {
		dev_info(&info->i2c_client->dev, "%s:BUSY!\n", __func__);
		return -EBUSY;
	}

	file->private_data = info;

	if (info->pdata && info->pdata->power_on)
		info->pdata->power_on();
	else {
		dev_err(&info->i2c_client->dev,
			"%s:no valid power_on function.\n", __func__);
		return -EEXIST;
	}

	return 0;
}

static int
ov9740_release(struct inode *inode, struct file *file)
{
	struct ov9740_info *info = file->private_data;

	if (info->pdata && info->pdata->power_off)
		info->pdata->power_off();
	file->private_data = NULL;

	/* warn if device is already released */
	WARN_ON(!atomic_xchg(&info->in_use, 0));
	return 0;
}


static const struct file_operations ov9740_fileops = {
	.owner = THIS_MODULE,
	.open = ov9740_open,
	.unlocked_ioctl = ov9740_ioctl,
	.release = ov9740_release,
};

static struct miscdevice ov9740_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "ov9740",
	.fops = &ov9740_fileops,
};

extern int tegra_camera_clk_onoff(int on);
static int
ov9740_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	struct ov9740_info *info;
	int err = 0;
	 u8 sensor_id_msb = 0;
	 u8 sensor_id_lsb = 0;
	 u16 sensor_id = 0;
	 
	printk("[ov9740]: probing sensor.\n");

	info = devm_kzalloc(&client->dev,
		sizeof(struct ov9740_info), GFP_KERNEL);
	if (!info) {
		pr_err("[ov9740]:%s:Unable to allocate memory!\n", __func__);
		return -ENOMEM;
	}

	info->pdata = client->dev.platform_data;
	info->i2c_client = client;
	atomic_set(&info->in_use, 0);
	info->mode = -1;

	i2c_set_clientdata(client, info);

	memcpy(&info->miscdev_info,
		&ov9740_device,
		sizeof(struct miscdevice));

	err = misc_register(&info->miscdev_info);
	if (err) {
		pr_err("[ov9740]:%s:Unable to register misc device!\n",
		__func__);
	}
	#if 1
	if (info->pdata && info->pdata->power_on)
		info->pdata->power_on();

       mdelay(10);
	   
        tegra_camera_clk_onoff(1);
        mdelay(10);
        ov9740_read_reg(info->i2c_client, 0x0000, &sensor_id_msb);
        ov9740_read_reg(info->i2c_client, 0x0001, &sensor_id_lsb);
        sensor_id = ((u16)sensor_id_msb << 8) |(u16)sensor_id_lsb ;
        printk("%s: ov9740 sensor_id = 0x%x\n",  __func__,sensor_id);
	 mdelay(10);	
        tegra_camera_clk_onoff(0);
        if (info->pdata && info->pdata->power_off) 
            info->pdata->power_off();
		
	#endif
	return err;
}

static int
ov9740_remove(struct i2c_client *client)
{
	struct ov9740_info *info = i2c_get_clientdata(client);
	misc_deregister(&ov9740_device);
	kfree(info);
	return 0;
}

static const struct i2c_device_id ov9740_id[] = {
	{ "ov9740", 0 },
};

MODULE_DEVICE_TABLE(i2c, ov9740_id);

static struct i2c_driver ov9740_i2c_driver = {
	.driver = {
		.name = "ov9740",
		.owner = THIS_MODULE,
	},
	.probe = ov9740_probe,
	.remove = ov9740_remove,
	.id_table = ov9740_id,
};

static int __init
ov9740_init(void)
{
	pr_info("ov9740] sensor driver loading\n");
	return i2c_add_driver(&ov9740_i2c_driver);
}

static void __exit
ov9740_exit(void)
{
	i2c_del_driver(&ov9740_i2c_driver);
}

module_init(ov9740_init);
module_exit(ov9740_exit);
